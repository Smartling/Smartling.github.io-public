---
  - Directive:      'placeholder_format_custom'
    Values:         '1. Custom regular expression (<a ref="http://www.pcre.org">pcre</a>)<br/>2. <strong>NONE</strong> - disable custom placeholders'
    Description:    'Used to define a custom placeholder format for strings in the file'
    Examples:
        - Code: 'smartling.placeholder_format_custom = \[.+?\]'
          CodeJSON: ''
          Description: 'Any characters surrounded by square brackets "[]" will be treated as a placeholder'

  - Directive:      'placeholder_format'
    Values:         '<code>NONE</code>; <code>C</code>; <code>IOS</code>; <code>PYTHON</code>; <code>JAVA</code>; <code>YAML</code>; <code>QT</code>; <code>RESX</code>'
    Description:    'Used to specify a standard placeholder format.'

  - Directive:      'string format'
    Values:         '<strong>MESSAGE_FORMAT</strong> (default) or <strong>NONE</strong>'
    Description:    'String format is a parser directive for specialized file processing that enables string escaping and pre-processing rules as defined by various third party resource handlers. The default is <a href="http://docs.oracle.com/javase/6/docs/api/java/text/MessageFormat.html">MessageFormat</a>, a standard Java resource handler.'

  - Directive:      'string_format_paths'
    Values:         'The grammar of the value'
    Description:    '<p>Specifies the format of strings for the specified paths and can enable HTML inside another file format.</p><p>Currently supported formats are:</p><ul><li><strong>HTML</strong> - string value will be parsed as HTML</li><li><strong>@default</strong> - (note the leading at-sign) string value will be treated as simple text.</li></ul><p>Separate multiple formats by commas</p> <p>You may specify a single path for a format or a comma-separated list of paths enclosed in square brackets. The list may be empty.</p> <p>A path is a slash-separated string which uses Xpath-like syntax (but it''s not Xpath.). The nodes separator is always / (slash), regardless of file format.</p> <p>Wildcards are allowed in path definitions.</p> <ul><li>If no wildcards, then the path identifies a single node and all its children ("exact subpath").</li><li>If wildcards, then a path identifies a set of nodes and all their children ("path pattern"). Currently, only * (asterisk) wildcard is implemented, which means "one or more nodes with any names".</li><li>Exact subpaths have precedence over path patterns.</li></ul> <p>For example, in the following instruction:</p> <pre>smartling.string_format_paths = html: [*/text, */string], @default: /system/log/text</pre> <p>Smartling processes these paths as follows:</p> <ul> <li><code>/description/text</code> — Processed as HTML (matches <code>*/text</code> pattern)</li> <li><code>/description/text/general</code> — HTML (its parent, <code>/description/text</code>, matches <code>*/text</code> pattern)</li> <li><code>/description/general/text</code> — HTML (matches <code>*/text</code> pattern directly).</li> <li><code>/system/log/text</code> — TEXT (matches both <code>/system/log/text</code> exact path and <code>*/text</code> pattern; exact path wins)</li> <li><code>/system/log/text/details</code> — TEXT (its parent, <code>/system/log/text</code>, matches both exact path and pattern; exact path wins)</li> </ul>'
    Examples:
        - Code: 'smartling.string_format_paths = html: *'
          CodeJSON: ''
          Description: 'Smartling parses values of all nodes as HTML.'

        - Code: 'smartling.string_format_paths = html: */text'
          CodeJSON: ''
          Description: 'Smartling enables HTML in <code>text</code> nodes (and their subnodes), regardless of their parents.'

        - Code: 'smartling.string_format_paths = html: [*/text, */string]'
          CodeJSON: ''
          Description: 'Smartling enables HTML in <code>text</code> and <code>string</code> nodes (and their subnodes), regardless of their parents'

        - Code: 'smartling.string_format_paths = html: */text, html: */string'
          CodeJSON: ''
          Description: 'Another way to enable HTML in <code>text</code> and <code>string</code> nodes (and subnodes).'

        - Code: 'smartling.string_format_paths = html: */text, @default: /system/log/text'
          CodeJSON: ''
          Description: 'Smartling enables HTML in <code>text</code> nodes (and subnodes), but disables HTML in <code>/system/log/text</code> (and subnodes)'

        - Code: 'smartling.string_format_paths = html: /product/description'
          CodeJSON: ''
          Description: 'Smartling enables HTML in /product/description and subnodes'

        - Code: 'smartling.string_format_paths = html: /product/descriptions/*'
          CodeJSON: ''
          Description: 'Smartling enables HTML in all subnodes of /product/descriptions, but not in this node itself.'

        - Code: 'smartling.string_format_paths = html: [*/translation, */text], @default: [/strings/12345/translation, /string/67890/text]'
          CodeJSON: ''
          Description: 'Another example of Smartling enabling HTML in all subnodes but not the not the two nodes.'

        - Code: 'smartling.string_format_paths ='
          CodeJSON: ''
          Description: 'Disables the effect of the previous string_format_paths instruction.'

  - Directive:      'translate_paths'
    Values:         'A comma-separated list of paths to be captured as strings for translation. <code>*</code> wildcards are permitted.'
    Description:    'When included in this list, all plain text within the specified tag will be considered a translatable string. Optionally, you can append a "." and a relevant attribute name to the path to translate tag attributes with the file. You can end the path with a trailing slash, "/" and it will treat all child nodes as translatable (content must still be text within a tag).'
    Examples:
        - CodeJSON: '"translate_paths": ["*/translation"]'
          Description: 'Smartling will tranlate content in any path ending in <code>translation</code>, such as <code>string/translation</code>, <code>nav/translation</code>, etc.'

        - CodeXML: 'smartling.translate_paths = data/localize/string, data/localize.title, data/localize/root/'
          Code: 'testcode'
          Description: 'Smartling will translate content in the data/localize/string & data/localize/root nodes. The <code>title</code> attribute of the data/localize node will also be translated.'


  - Directive:      'sltrans'
    Values:         '<code>translate</code> OR <code>notranslate</code>'
    Description:    'Use this directive to enable or disable processing of translation strings in the file. You must turn translation back on after the strings you want to exclude.'
    Examples:
        - Code: 'smartling.sltrans = notranslate'
          Description: 'Strings below this directive will be captured as strings but excluded from translation'

        - Code: 'smartling.sltrans = translate'
          Description: 'Strings below this directive will be translated'

  - Directive:      'source_key_paths'
    Values:         '<p>A comma separated list of paths to use create "keys" for strings on translate_paths.</p> <p>The key will be a space separated string of all the keys leading to the source string. For example: "string", "group1 string".</p>'
    Description:    '<p>Used to define the schema for capturing a key for each source string. Keys are required:</p><ul><li>If you want to import pre-existing translations from a file with the same structure</li><li>If you want to create variants of strings that would otherwise be duplicates (By default Smartling does not create duplicate strings.) <strong>Note:</strong> creating or updating variants for previously uploaded strings cause new strings to be created that will not have translations. The SmartMatch feature can be configured to automatically apply the existing translations, or translators can use the 100% match from the Translation to manually apply the translation.</li><p>Specify the full path to the value, then indicate which part of the path should be used as the key using {} notation. {*} will use any key present in that part of the path (or can be used when no translate_paths has been specified to simply capture the key for each string).</p>'
    Examples:
        - Code: 'smartling.source_key_paths = {*}'
          Description: 'Smartling will capture the full path of keys leading to each translatable string as Key metadata'

        - Code: 'smartling.source_key_paths = data/item/{string_name}'
          CodeXML: 'smartling.source_key_paths = data/item/{string_name}'
          CodeJSON: '"source_key_paths" : "data/item/{string_name}"'
          Description: 'smartling will capture the content from <code>string_name</code> as the key'

        - CodeXML: 'smartling.source_key_paths = data/item/{string.name}'
          Description: 'Smartling will capture the <code>name</code> atribute of the <code>data/item/string</code> node as the key.'

  - Directive:      'variants_enabled'
    Values:         '<code>true|TRUE|on|ON</code> OR <code>false|FALSE|off|OFF</code>'
    Description:    ''

  - Directive:      'instruction_comments_enabled'
    Values:         '<code>true</code> OR <code>false</code>'
    Description:    'If this directive is set to <code>true</code>, any comment in the file is ingested as an instruction for the next string.'
    Examples:
        - Code: '&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br/>&lt;!-- smartling.instruction_comments_enabled = on --&gt;<br/>&lt;resources&gt;<br/>&lt;!-- Instruction for string1 --&gt;<br/>&nbsp;&lt;string name=&quot;string1&quot;&gt;string1&lt;/string&gt;'
          Block: 'yes'
          Description: 'Smartling will capture String1 with the instruction "Instruction for String1"'

  - Directive:      'instruction_attributes'
    Values:         'Name of an attribute of string or plurals nodes in your file'
    Description:    'Sets attributes of content nodes to be captured as file instructions for strings.'
    Examples:
        - Code: '&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br/>&lt;!-- smartling.instruction_attributes = comment, note --&gt;<br/>&lt;resources&gt;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&lt;string name=&quot;string1&quot; comment=&quot;comment for String01&quot;&gt;String01&lt;/string&gt;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&lt;string name=&quot;string2&quot; comment=&quot;comment for String02&quot; note=&quot;note for String02&quot;&gt;String03&lt;/string&gt;'
          Block: 'yes'
          Description: 'string1 will be captured with the instruction "comment for String01". string2 will be captured with the concatenated instruction "comment for String02, note for String02"'

  - Directive:      'download_format'
    Values:         '<code>NONE</code>(default) OR <code>ESCAPE_UNICODE</code>'
    Description:    '<code>ESCAPE_UNICODE</code> indicates that all non-Latin1 (not in range 0000 - 007F of unicode) symbols after this comment should be escaped by a <code>\uXXXX</code> escaping expression in the process of a file download.'
    Examples:
        - Code: 'smartling.download_format = ESCAPE_UNICODE'
          Description: '<code>Hello ?</code> will be escaped as <code>Hello \u1D25</code> on download.'

  - Directive:      'force_inline_for_tags'
    Values:         'comma-separated html tag list'
    Description:    'This parameter forces the html parser to treat the listed tags as inline. The difference between block and inline tags is that block tags are used to split html into strings, whereas inline tags are included in strings.'
    Examples:
        - Code: 'smartling.force_inline_for_tags = external_link,reference'
          Description: 'Any <code>&lt;external_link&gt;</code> or <code>&lt;reference&gt;</code> tags will be parsed as inline tags. Smartling will not create separate strings for content in these tags.'

  - Directive:      'plurals_detection'
    Values:         '<code>on</code> OR <code>off</code>'
    Description:    '<p>Enables or disables plurals detection.</p> <p><strong>Note:</strong> if using plural detection for a YAML file as part of a Ruby on Rails project, ensure your project is set up with correct <a href="later">pluralization rules.</a>'
    Examples:
        - Code: 'smartling.force_inline_for_tags = external_link,reference'
          Description: 'Any <code>&lt;external_link&gt;</code> or <code>&lt;reference&gt;</code> tags will be parsed as inline tags. Smartling will not create separate strings for content in these tags.' 

 -  











































